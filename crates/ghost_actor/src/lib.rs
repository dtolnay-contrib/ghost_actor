#![forbid(unsafe_code)]
#![forbid(warnings)]
#![forbid(missing_docs)]
#![allow(dead_code)]
//! A simple, ergonomic, idiomatic, macro for generating the boilerplate
//! to use rust futures tasks in a concurrent actor style.

// https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=49ed11fb1bb1237256a9aa29d539e306

use inflector::Inflector;
use proc_macro2::{Ident, TokenStream};
use quote::*;

/// re-exported dependencies
pub mod dependencies {
    pub use ::futures;
}

mod parse_trait;

/// Generic GhostActor Error Type
#[derive(Debug)]
pub struct GhostError(Box<dyn std::error::Error + Send + Sync>);

impl std::fmt::Display for GhostError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for GhostError {}

impl GhostError {
    /// Convert a std Error into a GhostError
    pub fn other<E: 'static + std::error::Error + Send + Sync>(e: E) -> Self {
        Self(e.into())
    }
}

/*
impl<E: 'static + std::error::Error + Send + Sync> From<E> for GhostError {
    fn from(e: E) -> Self {
        Self(Box::new(e))
    }
}
*/

impl From<GhostError> for () {
    fn from(_: GhostError) -> Self {}
}

/// Application of this trait means your item can act as a GhostActor.
pub trait GhostActor: 'static + Send {}

/// This trait is additinally applied to senders built to reference GhostActors.
pub trait GhostSender: GhostActor + Sized + Clone {
}

/// To be used in a derive macro proc-macro crate (ghost_actor_derive).
pub fn ghost_actor_macro(input: TokenStream) -> TokenStream {
    let parsed = parse_trait::parse_trait(input.clone());

    let enum_name = format_ident!(
        "_ghost_actor_enum_{}_",
        parsed.name.to_string().to_snake_case(),
    );
    let trait_name = format_ident!("{}", parsed.name);
    let sender_name = format_ident!("{}Sender", parsed.name);
    let spawn_name = format_ident!(
        "spawn_{}_actor",
        parsed.name.to_string().to_snake_case(),
    );

    let enum_variants = gen_enum_variants(&parsed);
    let recv_handlers = gen_recv_handlers(&enum_name, &parsed);
    let fn_impls = gen_fn_impls(&enum_name, &parsed);

    quote! {
        #input

        enum #enum_name {
            #enum_variants
        }

        /// The sender type generated by actor_spawn
        pub struct #sender_name(::ghost_actor::dependencies::futures::channel::mpsc::Sender<#enum_name>);

        impl ::std::clone::Clone for #sender_name {
            fn clone(&self) -> Self {
                Self(self.0.clone())
            }
        }

        impl ::ghost_actor::GhostActor for #sender_name {}

        impl #trait_name for #sender_name {
            #fn_impls
        }

        /// The spawn fn
        pub fn #spawn_name<T: ::ghost_actor::GhostActor + #trait_name>(mut i: T) -> #sender_name {
            let (msg_send, mut msg_recv) = ::ghost_actor::dependencies::futures::channel::mpsc::channel(10);

            ::tokio::task::spawn(async move {
                while let Some(msg) = ::ghost_actor::dependencies::futures::stream::StreamExt::next(&mut msg_recv).await {
                    match msg {
                        #recv_handlers
                    }
                }
            });

            #sender_name(msg_send)
        }
    }
}

fn gen_enum_variants(parsed: &parse_trait::ParsedTrait) -> TokenStream {
    let mut out = Vec::new();
    for f in parsed.fns.iter() {
        let mut args = Vec::new();
        let output = &f.output;
        args.push(quote! {
            _ghost_actor_respond_: ::ghost_actor::dependencies::futures::channel::oneshot::Sender<#output>,
        });
        for a in f.args.iter() {
            let name = &a.0;
            let ty = &a.1;
            args.push(quote! {
                #name: #ty,
            });
        }
        let name = format_ident!("{}", (&f.name).to_string().to_pascal_case());
        out.push(quote! {
            #name { #(#args)* },
        });
    }
    quote!(#(#out)*)
}

fn gen_recv_handlers(enum_name: &Ident, parsed: &parse_trait::ParsedTrait) -> TokenStream {
    let mut out = Vec::new();
    for f in parsed.fns.iter() {
        let mut arg_names = Vec::new();
        for a in f.args.iter() {
            arg_names.push(format_ident!("{}", a.0.to_string()));
        }
        let name = &f.name;
        let e_name = format_ident!("{}", (&f.name).to_string().to_pascal_case());
        out.push(quote! {
            #enum_name::#e_name { _ghost_actor_respond_, #(#arg_names,)* } => {
                let fut = i.#name( #(#arg_names,)* );
                let _ = _ghost_actor_respond_.send(fut);
            }
        });
    }
    quote!(#(#out)*)
}

fn gen_fn_impls(enum_name: &Ident, parsed: &parse_trait::ParsedTrait) -> TokenStream {
    let mut out = Vec::new();
    for f in parsed.fns.iter() {
        let mut arg_names = Vec::new();
        for a in f.args.iter() {
            arg_names.push(format_ident!("{}", a.0.to_string()));
        }
        let mut args = Vec::new();
        for a in f.args.iter() {
            let name = &a.0;
            let ty = &a.1;
            args.push(quote! {
                #name: #ty,
            });
        }
        let name = &f.name;
        let e_name = format_ident!("{}", (&f.name).to_string().to_pascal_case());
        let output = &f.output;
        out.push(quote! {
            fn #name(&mut self, #(#args)*) -> #output {
                let (send, recv) = ::ghost_actor::dependencies::futures::channel::oneshot::channel();
                let mut sender = self.0.clone();
                use ::ghost_actor::dependencies::futures::sink::SinkExt;
                ::ghost_actor::dependencies::futures::future::FutureExt::boxed(async move {
                    sender.send(#enum_name::#e_name {
                        _ghost_actor_respond_: send,
                        #(#arg_names,)*
                    }).await.map_err(::ghost_actor::GhostError::other)?;
                    let fut = recv.await.map_err(::ghost_actor::GhostError::other)?;
                    fut.await
                })
            }
        });
    }
    quote!(#(#out)*)
}

/// If rustfmt is available on the path, will attempt to format a TokenStream.
/// Otherwise, just returns `TokenStream::to_string()`.
pub fn try_fmt(tokens: TokenStream) -> String {
    let tokens = tokens.to_string();
    let res = (|| {
        let mut rustfmt = std::process::Command::new("rustfmt")
            .arg("--edition")
            .arg("2018")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .spawn()?;
        use std::io::Write;
        write!(rustfmt.stdin.take().unwrap(), "{}", &tokens)?;
        let output = rustfmt.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        std::io::Result::Ok(stdout)
    })();
    res.unwrap_or(tokens)
}

#[cfg(test)]
mod test;
