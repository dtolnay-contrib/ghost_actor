#![forbid(unsafe_code)]
#![forbid(warnings)]
#![forbid(missing_docs)]
//! A simple, ergonomic, idiomatic, macro for generating the boilerplate
//! to use rust futures tasks in a concurrent actor style.

// https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=49ed11fb1bb1237256a9aa29d539e306

use inflector::Inflector;
use proc_macro2::TokenStream;
use quote::*;

mod parse_trait;

/// Application of this trait means your item can act as a GhostActor.
pub trait GhostActor: 'static + Send {}

/// To be used in a derive macro proc-macro crate (ghost_actor_derive).
pub fn ghost_actor_derive(input: TokenStream) -> TokenStream {
    let parsed = parse_trait::parse_trait(input);

    let trait_name = format_ident!("{}", parsed.name);
    let sender_name = format_ident!("{}Sender", parsed.name);
    let spawn_name = format_ident!(
        "spawn_{}_actor",
        parsed.name.to_string().to_snake_case()
    );

    quote! {
        impl GhostActor for #trait_name {}

        /// The sender type generated by actor_spawn
        pub type #sender_name = Box<dyn #trait_name + 'static + Send>;

        /// The spawn fn
        pub fn #spawn_name<T: #trait_name>(i: T) -> #sender_name {
            unimplemented!()
        }
    }
}

/// If rustfmt is available on the path, will attempt to format a TokenStream.
/// Otherwise, just returns `TokenStream::to_string()`.
pub fn try_fmt(tokens: TokenStream) -> String {
    let tokens = tokens.to_string();
    let res = (|| {
        let mut rustfmt = std::process::Command::new("rustfmt")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .spawn()?;
        use std::io::Write;
        write!(rustfmt.stdin.take().unwrap(), "{}", &tokens)?;
        let output = rustfmt.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        std::io::Result::Ok(stdout)
    })();
    res.unwrap_or(tokens)
}

#[cfg(test)]
mod test;
